#!/bin/python
from dataclasses import dataclass
import getopt
import sys
import os
import json
import datetime
from collections import defaultdict
from typing import Any

import requests

section = "languages"
exclude_langs: list[str] = []
include_langs: list[str] = []

use_included_total = 0

print_reversed = 0

milestones: list[float | int] = [50]

time_milestones: list[str] = []

to_find = ""

qual_gt = ""

api = ""
user = ""

top = -1

ansi_enabled = sys.stdout.isatty()

valid_ranges=[
    "today",
    "yesterday",
    "week",
    "month",
    "year",
    "last_7_days",
    "7_days",
    "last_30_days",
    "30_days",
    "last_6_months",
    "6_months",
    "last_12_months",
    "12_months",
    "last_year",
    "any",
    "all_time"
]

used_range = "any"
start_time = ""
end_time = ""

read_from = ""
data_fmt = "stats"

output_fmt = "line"

def gen_help():
    print(f"""lang-stats [TprxiautAefSERlO] [qualifiers...]
        Use wakapi to print language/project usage stats

        QUALIFIERS:
          either a percentage (integer) or a time "[h]:[m]:[s]"

        OPTIONS:
        u <user>           : the user to print stats for
        l                  : print the leaderboard
        t <number>         : display the top <number> languages/projects
        p                  : print project times instead of language times
        r <range>          : time range, one of:
        R                  : print from least -> greatest
                                {"\n\t\t\t\t".join(valid_ranges)}
        x <names>          : exclude a ',' separated list of languages/projects
                             can be used multiple times.
                             Mutually exclusive with -i
        i <names>          : Similar to -x but ONLY show the languages listed with -i
                             Mutually exclusive with -x
        T                  : When using -x or -i,
                             use only the sum of the time from the included languages/projects
                             as the total time instead of the total time of ALL languages/projects
        a <domain>         : use <domain> as the api url base
        A                  : disbale ansi sequences
                             (automatically disabled when stdout is not a terminal)
        e                  : enable ansi sequences

        f <file>           : read stats form a file (-) for stdin
        F <   summary      : set the data format stats, summary, or leaders
            | stats          settings to leaders will display a leaderboard
            | leaders
          >
                           : also sets -r to today (use -r after to override)
        O <  line
           | combine-users
          >                : "line": output each item one at a time for each user
                           : "combine-users": combine each user's language totals and print

        S <start>          : start time
                             sets -F to summary as it's necessary
                             also sets -r to ''
        E <end>            : end time
                             sets -F to summary as it's necessary
                             also sets -r to ''

        --find <most-used> : finds the most used languages accross all users
                             same as -o combine-users -F leaders

        --gt <qual>        : only include languages/projects greater than
                             a qualifier

        ARGUMENTS:
        qualifiers... :
                    each arg is treated as a percentage or time to print to label
                    how many languages are needed to add up
                    to that percentage or time. If only "0" is provided as a
                    percentage, no percentage or time will be printed.
""")

args = sys.argv
opts, args = getopt.getopt(args[1:], "hTpr:x:i:a:u:t:Aef:F:S:E:RO:", ["find=", "gt="])

for opt, optarg in opts:
    match opt.lstrip('-'):
        case 'gt':
            qual_gt = optarg
        case 'find':
            valid_finds = ("most-used",)
            to_find = optarg
            if not to_find in valid_finds:
                print(f"{to_find} is not one of {", ".join(valid_finds)}", file=sys.stderr)
                exit(1)
            # if to_find == "most-used":
            #     data_fmt = "leaders"
            #     output_fmt = "combine-users"
        case "O":
            output_fmt = optarg
        case "t":
            top = int(optarg)
        case "p":
            section = "projects"
        case "R":
            print_reversed = 1
        case "r":
            used_range = optarg
            shortcuts = {
                    "t": "today",
                    "w": "week",
                    "m": "month",
                    "30": "last_30_days",
            }
            used_range = shortcuts.get(used_range, used_range)

            if used_range not in valid_ranges:
                print(f"Not a valid range: {used_range} setting back to any",
                      file=sys.stderr)
        case "T":
            use_included_total = 1
        case "x":
            include_langs = []
            exclude_langs += [k.strip().lower() for k in optarg.split(",")]
        case 'i':
            exclude_langs = []
            include_langs += [k.strip().lower() for k in optarg.split(",")]
        case 'a':
            api = optarg
        case 'u':
            user = optarg
        case 'e':
            ansi_enabled = 1
        case 'A':
            ansi_enabled = 0
        case 'f':
            read_from = optarg
        case 'S':
            used_range = ""
            start_time = optarg
        case 'E':
            used_range = ""
            end_time = optarg
        case 'F':
            data_fmt = optarg
            used_range = "today"
        case 'h':
            gen_help()
            exit()
        case INVALID:
            print(f"Invalid option {INVALID}", file=sys.stderr)
            exit(1)

if not api:
    print("No api url given", file=sys.stderr)
    exit(1)

if not user and data_fmt != "leaders":
    print("No user given", file=sys.stderr)
    exit(1)

def convertsecs(secs: int):
    h = secs // 3600
    m = (secs % 3600) // 60
    s = secs % 60
    return f"{h:02d}:{m:02d}:{s:02d}"

def time2secs(time: str):
    hours, mins, secs = time.split(":")
    return int(hours or "0") * 3600 + int(mins or "0") * 60 + int(secs or "0")

def lang_counter():
    langs_included = 0

    def include_lang(lang: str, time_secs: int, pct: float):
        nonlocal langs_included

        lang = lang.lower()

        langs_included += 1

        if top > 0 and langs_included > top:
            return False

        if exclude_langs and lang in exclude_langs:
            return False

        if include_langs and lang not in include_langs:
            return False

        return True

    return include_lang

def print_line_item(name: str, time: str, pct: float, *, clr="35"):
    text = f"\x1b[{clr}m{name}\x1b[0m" if ansi_enabled else name
    text += f" {time} ({pct:.2f}%)"
    text += "\x1b[0m" if ansi_enabled else ""
    print(text)

def get_clr_from_list_and_cur(l: list[Any], cur: int):
    if print_reversed and len(l) - cur < 6:
        return f"3{len(l) - cur}"
    elif not print_reversed and cur < 6:
        return f"3{cur + 1}"
    else:
        return "0"

def language_printer(user_langs = None):
    lang_count = 0

    total_pct = 0
    total_secs = 0

    milestones_iter =  iter(sorted(milestones))
    cur_milestone = next(milestones_iter, -1)

    time_milestones_iter = iter(sorted(time_milestones, key=time2secs))
    cur_time_milestone = next(time_milestones_iter, "")

    def print_lang_list(langs, total_secs_included: int):
        nonlocal total_pct, total_secs, lang_count, cur_milestone, cur_time_milestone

        for i, item in enumerate(langs):
            name = item["name"]

            secs = item["total_seconds"]

            if use_included_total:
                pct = secs / total_secs_included * 100
            else:
                pct = item["percent"]

            if qual_gt:
                milestones, time_milestones = parse_qualifiers([qual_gt])

                if milestones and pct < milestones[0]:
                    continue

                if time_milestones and secs < time2secs(time_milestones[0]):
                    continue


            total_pct += pct

            total_secs += secs
            lang_count += 1

            clr = get_clr_from_list_and_cur(langs, i)

            print_line_item(name, convertsecs(secs), pct, clr=clr)
            if user_langs:
                for user, dat in sorted(user_langs.items(), key=lambda u: u[1][name], reverse = True):
                    if not dat[name]: continue
                    if ansi_enabled:
                        print(f"\x1b[2m", end="")
                    print(f"{user} {convertsecs(dat[name])} ({dat[name] / secs * 100:0.2f}%)")
                    if ansi_enabled:
                        print("\x1b[0m", end="")

            while cur_milestone > 0 and total_pct > cur_milestone:
                print_line_item(f"{cur_milestone}%-({lang_count})", convertsecs(total_secs), total_pct, clr="35;1")
                # print(f"\x1b[1m{cur_milestone}%-({lang_count}) {convertsecs(total_secs)} ({total_pct:.2f}%)\x1b[0m")
                cur_milestone = next(milestones_iter, -1)

            while cur_time_milestone and total_secs > time2secs(cur_time_milestone):
                print_line_item(f"{cur_time_milestone}-({lang_count})", convertsecs(total_secs), total_pct, clr="95")
                # print(f"\x1b[1m{cur_time_milestone}-({lang_count}) {convertsecs(total_secs)} ({total_pct:.2f}%)\x1b[0m")
                cur_time_milestone = next(time_milestones_iter, "")

        return total_secs, total_pct

    return print_lang_list

@dataclass
class DataPoint:
    name: str
    total_seconds: int

@dataclass
class User:
    name: str
    total_seconds: int
    datapoints: list[DataPoint]

    def apply_include(self, total_seconds: int):
        include = lang_counter()
        new = []
        for datapoint in self.datapoints:
            if not include(datapoint.name, datapoint.total_seconds, datapoint.total_seconds / total_seconds * 100):
                continue
            new.append(datapoint)
        self.datapoints = new

    def getdpByName(self, name: str):
        v = filter(lambda k: k.name == name, self.datapoints)
        for res in v:
            return res

@dataclass
class CombinedUser(User):
    original_users: dict[str, User]

@dataclass
class STDData:
    users: list[User | CombinedUser]
    total_seconds: int
    day_count: int
    start: int | None = None
    end: int | None = None

    def apply_include(self):
        for user in self.users:
            user.apply_include(self.total_seconds)

    def print_users(self, users: list[User]):
        for user in users:
            if len(users) > 1:
                print(f"- {user.name.upper()} -")
            stats = user.datapoints
            if print_reversed:
                stats = [*reversed(stats)]

            time_total = self.day_count * 86400

            total_secs_included = 0

            langs = []
            for item in stats:
                total_secs_included += item.total_seconds
                langs.append({"name": item.name, "total_seconds": item.total_seconds, "percent": item.total_seconds / self.total_seconds * 100})

            printer = language_printer()

            total_secs, total_pct = printer(langs, total_secs_included)

            print(f"--------------\nTOTAL: {convertsecs(total_secs)} ({total_pct:.02f}%)")
            print(f"--------------\nAVG {convertsecs(round(total_secs / time_total * 86400))} time/day\n")

    def print_line_items(self, label: str = ""):
        if label:
            print(f"------------------\n{label}\n------------------")

        self.print_users(self.users)

    def apply_combine_users(self):
        langs = {}
        user_langs = defaultdict(lambda: defaultdict(int))
        total_secs_included = 0
        for user in self.users:
            for datapoint in user.datapoints:
                user_langs[user.name][datapoint.name] += datapoint.total_seconds

                if langs.get(datapoint.name):
                    langs[datapoint.name] += datapoint.total_seconds
                else:
                    langs[datapoint.name] = datapoint.total_seconds
                total_secs_included += datapoint.total_seconds

        self.users = [CombinedUser("COMBINED", total_secs_included, [
                DataPoint(name, s) for name, s in langs.items()
                ], original_users = {u.name: u for u in self.users})]

    def print_combined_users(self):
        langs = {}
        user_langs = defaultdict(lambda: defaultdict(int))
        total_secs_included = 0
        for user in self.users:
            for datapoint in user.datapoints:
                if isinstance(user, CombinedUser):
                    for og in user.original_users:
                        dp = user.original_users[og].getdpByName(datapoint.name)
                        if dp:
                            user_langs[og][datapoint.name] += dp.total_seconds
                else:
                    user_langs[user.name][datapoint.name] += datapoint.total_seconds

                if langs.get(datapoint.name):
                    langs[datapoint.name] += datapoint.total_seconds
                else:
                    langs[datapoint.name] = datapoint.total_seconds
                total_secs_included += datapoint.total_seconds

        langs = [{"name": name, "total_seconds": s, "percent": s / self.total_seconds * 100} for name, s in sorted(langs.items(), key = lambda i: i[1], reverse = True)]

        printer = language_printer(user_langs)
        total_secs, total_pct = printer(langs, total_secs_included)
        print(f"--------------\nTOTAL: {convertsecs(total_secs)} ({total_pct:.02f}%)")
        print(f"--------------\nAVG {convertsecs(round(total_secs / self.total_seconds * 86400))} time/day\n")

def parse_qualifiers(quals: list[str]):
    milestones = []
    time_milestones = []
    for qual in quals:
        if ":" in qual:
            time_milestones.append(qual)
        else:
            milestones.append(float(qual))
    return milestones, time_milestones

if args:
    milestones, time_milestones = parse_qualifiers(args)

std = STDData([], 0, 0)

for user in user.split(","):
    if read_from:
        if read_from == "-":
            raw = json.loads("".join(sys.stdin.readlines()))
        else:
            with open(read_from) as f:
                raw = json.load(f)

    elif data_fmt == "stats":
        raw = requests.get(f"{api}/api/compat/wakatime/v1/users/{user}/stats/{used_range}")
        raw = raw.json()
    elif data_fmt == "leaders":
        req = requests.get(f"{api}/api/compat/wakatime/v1/leaders")
        raw = req.json()
    else:
        key = os.getenv("WAKA_KEY")
        if not key:
            print("the $WAKA_KEY env var must be set to use -F without -f", file=sys.stderr)
            exit(1)
        params = {}
        if used_range:
            params["range"] = used_range
        elif start_time == '' or end_time == '':
            print("Cannot use -F summary with no -f without setting -S AND -E", file=sys.stderr)
            exit(1)
        if start_time:
            params["start"] = start_time
            params["end"] = end_time
        raw = requests.get(f"{api}/api/compat/wakatime/v1/users/{user}/summaries", params=params, headers={
            "Authorization": f"Basic {key}"
            })
        raw = raw.json()

    if data_fmt == "stats":
        std.users.append(
                User(
                    raw["data"]["username"],
                    raw["data"]["total_seconds"],
                    [DataPoint(name=l["name"], total_seconds=l["total_seconds"]) for l in raw["data"][section]]
                )
        )
        std.total_seconds += raw["data"]["total_seconds"]
        #not += because it's not communitive
        std.day_count = raw["data"]["days_including_holidays"] + 1

    #-Fleaders ignores -u
    elif data_fmt == "leaders":
        start_ts = datetime.datetime.strptime(raw["range"]["start_date"][0:10], "%Y-%m-%d")
        end_ts = datetime.datetime.strptime(raw["range"]["end_date"][0:10], "%Y-%m-%d")
        day_count = int((end_ts.timestamp() - start_ts.timestamp()) / 86400)
        total_seconds = 0
        for user in raw["data"]:
            total_seconds += user["running_total"]["total_seconds"]
        std = STDData(
                users = [User(
                             u["user"]["display_name"],
                             u["running_total"]["total_seconds"],
                             [DataPoint(**d) for d in u["running_total"]["languages"]]
                         ) for u in raw["data"]
                         ],
                day_count = day_count,
                total_seconds = total_seconds
        )
    elif data_fmt == "summary":
        day_count = raw["daily_average"]["days_including_holidays"]
        datapoints = {}
        seconds = 0
        for day in raw["data"]:
            start = day["range"]["start"][0:19]
            end = day["range"]["end"][0:19]
            day = day[section]
            for dp in day:
                seconds += dp["total_seconds"]
                if datapoints.get(dp["name"]):
                    datapoints[dp["name"]] += dp["total_seconds"]
                else:
                    datapoints[dp["name"]] = dp["total_seconds"]

        datapoints = [DataPoint(name = name, total_seconds = s) for name, s in sorted(datapoints.items(), key = lambda i: i[1], reverse = True)]
        std.day_count = day_count
        std.total_seconds += seconds
        std.users.append(User(name = user or "UNKNOWN", datapoints = datapoints, total_seconds = seconds))

    else:
        exit()

if to_find == "most-used":
    std.apply_combine_users()
if include_langs or exclude_langs or top > 0:
    std.apply_include()

if output_fmt == "line":
    std.print_line_items()
elif output_fmt == "combine-users":
    std.print_combined_users()
