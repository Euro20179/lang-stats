#!/bin/python
import getopt
import sys
import os
import json
import datetime

from dataclasses import dataclass
from collections import defaultdict
from urllib import request
from urllib.parse import urlencode

from typing import Any

section = "languages"
exclude_langs: list[str] = []
include_langs: list[str] = []

"""
{
        "small-project1": "BIG_PROJECT",
        "small-project2": "BIG_PROJECT"
}
will combine all stats for small-project1 and small-project2 as BIG_PROJECT
"""
combine_as: dict[str, str] = {}

use_included_total = 0

print_reversed = 0

milestones: list[float | int] = [50]

time_milestones: list[str] = []

to_find = ""

qual_gt = ""
qual_lt = ""

api = ""
user = ""

top = -1

ansi_enabled = sys.stdout.isatty()

valid_ranges=[
    "today",
    "yesterday",
    "week",
    "month",
    "year",
    "last_7_days",
    "7_days",
    "last_30_days",
    "30_days",
    "last_6_months",
    "6_months",
    "last_12_months",
    "12_months",
    "last_year",
    "any",
    "all_time"
]

used_range = "any"
start_time = ""
end_time = ""
for_project = ""

read_from = ""
data_fmt = "stats"

output_fmt = "line"

def gen_help():
    print(f"""lang-stats [options...] [qualifiers...]
        ALSO SEE lang-stats(1)

        OPTIONS:
        a <domain>         : use <domain> as the api url base
        u <user>           : the user to print stats for
        t <number>         : display the top <number> languages/projects
        p                  : print project times instead of language times
                             (same as --section=projects)
          --section        : use a specific section (default: languages)
        r <range>          : time range, one of:
                                {"\n\t\t\t\t".join(valid_ranges)}
        R                  : print from least -> greatest
        x <names>          : exclude a ',' separated list of languages/projects
                             can be used multiple times.
                             Mutually exclusive with -i
        i <names>          : Similar to -x but ONLY show the languages listed with -i
                             Mutually exclusive with -x
        T                  : When using -x or -i,
                             use only the sum of the time from the included languages/projects
                             as the total time instead of the total time of ALL languages/projects
        A                  : disbale ansi sequences
                             (automatically disabled when stdout is not a terminal)
        e                  : enable ansi sequences

        f <file>           : read stats form a file (-) for stdin
        F <   summary      : set the data format stats, summary, or leaders
            | stats          settings to leaders will display a leaderboard
            | leaders
          >
                           : also sets -r to today (use -r after to override)
        O <  line
           | combine-users
          >                : "line": output each item one at a time for each user
                           : "combine-users": combine each user's language totals and print

        S <start>          : start time
                             sets -F to summary as it's necessary
                             also sets -r to ''
        E <end>            : end time
                             sets -F to summary as it's necessary
                             also sets -r to ''
        P <project>        : apply a project filter to the wakatime call

        ARGUMENTS:
        qualifiers... :
                    each arg is treated as a percentage or time to print to label
                    how many languages are needed to add up
                    to that percentage or time. If only "0" is provided as a
                    percentage, no percentage or time will be printed.
                    see lang-stats(1) for more info
""")

args = sys.argv
opts, args = getopt.getopt(args[1:], "hTpr:x:i:a:u:t:Aef:F:S:E:RO:P:C:", ["find=", "gt=", "lt=", "section="])

for opt, optarg in opts:
    match opt.lstrip('-'):
        case 'C':
            for pair in optarg.split(":"):
                umbrella, langs = pair.split("=")
                langs = langs.split(",")
                for lang in langs:
                    combine_as[lang] = umbrella
        case 'gt':
            qual_gt = optarg
        case 'lt':
            qual_lt = optarg
        case 'section':
            section = optarg
        case 'find':
            valid_finds = ("most-used",)
            to_find = optarg
            if not to_find in valid_finds:
                print(f"{to_find} is not one of {", ".join(valid_finds)}", file=sys.stderr)
                exit(1)
            # if to_find == "most-used":
            #     data_fmt = "leaders"
            #     output_fmt = "combine-users"
        case "O":
            output_fmt = optarg
        case "t":
            top = int(optarg)
        case "p":
            section = "projects"
        case "R":
            print_reversed = 1
        case "r":
            used_range = optarg
            shortcuts = {
                    "t": "today",
                    "w": "week",
                    "m": "month",
                    "30": "last_30_days",
            }
            used_range = shortcuts.get(used_range, used_range)

            if used_range not in valid_ranges:
                print(f"Not a valid range: {used_range} setting back to any",
                      file=sys.stderr)
        case "T":
            use_included_total = 1
        case "x":
            include_langs = []
            exclude_langs += [k.strip().lower() for k in optarg.split(",")]
        case 'i':
            exclude_langs = []
            include_langs += [k.strip().lower() for k in optarg.split(",")]
        case 'a':
            api = optarg
        case 'u':
            user = optarg
        case 'e':
            ansi_enabled = 1
        case 'A':
            ansi_enabled = 0
        case 'f':
            read_from = optarg
        case 'S':
            used_range = ""
            start_time = optarg
            data_fmt = "summary"
        case 'E':
            used_range = ""
            end_time = optarg
            data_fmt = "summary"
        case 'P':
            for_project = optarg
        case 'F':
            data_fmt = optarg
            #see -F in lang-stats(1)
            if not start_time and (used_range == "any" or used_range == "all_time"):
                used_range = "today"
        case 'h':
            gen_help()
            exit()
        case INVALID:
            print(f"Invalid option {INVALID}", file=sys.stderr)
            exit(1)

if not api and not read_from:
    print("No api url given", file=sys.stderr)
    exit(1)

if not user and data_fmt != "leaders":
    print("No user given", file=sys.stderr)
    exit(1)

def convertsecs(secs: int):
    h = secs // 3600
    m = (secs % 3600) // 60
    s = secs % 60
    return f"{h:02d}:{m:02d}:{s:02d}"

def time2secs(time: str):
    hours, mins, secs = time.split(":")
    return int(hours or "0") * 3600 + int(mins or "0") * 60 + int(secs or "0")

def lang_counter():
    langs_included = 0

    def include_lang(lang: str, time_secs: int, pct: float):
        nonlocal langs_included

        lang = lang.lower()

        if top > 0 and langs_included >= top:
            return False

        if exclude_langs and lang in exclude_langs:
            return False

        if include_langs and lang not in include_langs:
            return False

        #this needs to be at the bottom so that -t is more powerful than -x
        #ie: if -t10 and -xhtml are given, even if html is in the top 10
        #we still get 10 results, as opposed to 9 if this is
        #above the other qualifiers
        langs_included += 1

        return True

    return include_lang

def print_line_item(name: str, time: str, pct: float, *, clr="35"):
    text = f"\x1b[{clr}m{name}\x1b[0m" if ansi_enabled else name #]]
    text += f" {time} ({pct:.2f}%)"
    text += "\x1b[0m" if ansi_enabled else "" #]
    print(text)

def get_clr_from_list_and_cur(l: list[Any], cur: int):
    if print_reversed and len(l) - cur < 6:
        return f"3{len(l) - cur}"
    elif not print_reversed and cur < 6:
        return f"3{cur + 1}"
    else:
        return "0"

def language_printer(user_langs = None):
    lang_count = 0

    total_pct = 0
    total_secs = 0

    milestones_iter =  iter(sorted(milestones))
    cur_milestone = next(milestones_iter, -1)

    time_milestones_iter = iter(sorted(time_milestones, key=time2secs))
    cur_time_milestone = next(time_milestones_iter, "")

    def print_lang_list(langs, total_secs_included: int):
        nonlocal total_pct, total_secs, lang_count, cur_milestone, cur_time_milestone

        for i, item in enumerate(langs):
            name = item["name"]

            secs = item["total_seconds"]

            if use_included_total:
                pct = secs / total_secs_included * 100
            else:
                pct = item["percent"]


            total_pct += pct

            total_secs += secs
            lang_count += 1

            clr = get_clr_from_list_and_cur(langs, i)

            print_line_item(name, convertsecs(secs), pct, clr=clr)
            if user_langs:
                for user, dat in sorted(user_langs.items(), key=lambda u: u[1][name], reverse = True):
                    if not dat[name]: continue
                    if ansi_enabled:
                        print(f"\x1b[2m", end="") #]
                    print(f"{user} {convertsecs(dat[name])} ({dat[name] / secs * 100:0.2f}%)")
                    if ansi_enabled:
                        print("\x1b[0m", end="") #]

            while cur_milestone > 0 and total_pct > cur_milestone:
                print_line_item(f"{cur_milestone}%-({lang_count})", convertsecs(total_secs), total_pct, clr="35;1")
                cur_milestone = next(milestones_iter, -1)

            while cur_time_milestone and total_secs > time2secs(cur_time_milestone):
                print_line_item(f"{cur_time_milestone}-({lang_count})", convertsecs(total_secs), total_pct, clr="95")
                cur_time_milestone = next(time_milestones_iter, "")

        return total_secs, total_pct

    return print_lang_list

@dataclass
class DataPoint:
    name: str
    total_seconds: int

@dataclass
class User:
    name: str
    total_seconds: int
    datapoints: list[DataPoint]

    def apply_include(self, total_seconds: int):
        include = lang_counter()
        new = []
        for datapoint in self.datapoints:
            if not include(datapoint.name, datapoint.total_seconds, datapoint.total_seconds / total_seconds * 100):
                continue
            new.append(datapoint)
        self.datapoints = new

    def apply_combine(self, combine_as: dict[str, str]):
        new = []
        combined_dps: defaultdict[str, str] = defaultdict(str)
        combined_dps_time: defaultdict[str, int] = defaultdict(int)
        for dp in self.datapoints:
            if dp.name in combine_as:
                combined_dps[dp.name] = combine_as[dp.name]
                combined_dps_time[combine_as[dp.name]] += dp.total_seconds
            else:
                new.append(dp)

        for combined_lang, time in combined_dps_time.items():
            new.append(DataPoint(combined_lang, time))

        new = sorted(new, key=lambda d: d.total_seconds, reverse = True)

        self.datapoints = new

    def apply_qual(self, total_seconds: int, qual_gt = "", qual_lt = ""):
        new = []
        milestones_gt, time_milestones_gt = parse_qualifiers([qual_gt])
        milestones_lt, time_milestones_lt = parse_qualifiers([qual_lt])
        for datapoint in self.datapoints:
            if milestones_gt and datapoint.total_seconds / total_seconds * 100 < milestones_gt[0]:
                continue

            if time_milestones_gt and datapoint.total_seconds < time2secs(time_milestones_gt[0]):
                continue

            if milestones_lt and datapoint.total_seconds / total_seconds * 100 > milestones_lt[0]:
                continue

            if time_milestones_lt and datapoint.total_seconds > time2secs(time_milestones_lt[0]):
                continue

            new.append(datapoint)
        self.datapoints = new

    def getdpByName(self, name: str):
        v = filter(lambda k: k.name == name, self.datapoints)
        for res in v:
            return res

@dataclass
class CombinedUser(User):
    original_users: dict[str, User]

@dataclass
class STDData:
    users: list[User | CombinedUser]
    total_seconds: int
    day_count: int
    total_include_seconds: int = 0
    start: int | None = None
    end: int | None = None

    def apply_include(self):
        for user in self.users:
            user.apply_include(self.total_seconds)
        #we removed some items, we should recaulcate the total included secs
        self.calculate_total_included_secs()

    def apply_qual(self, qual_gt = "", qual_lt = ""):
        for user in self.users:
            user.apply_qual(self.total_include_seconds, qual_gt, qual_lt)
        #we removed some items, we should recaulcate the total included secs
        self.calculate_total_included_secs()

    def apply_combine(self, combine_as: dict[str, str]):
        for user in self.users:
            user.apply_combine(combine_as)
        self.calculate_total_included_secs()

    def calculate_total_included_secs(self):
        self.total_include_seconds = 0
        for user in self.users:
            for datapoint in user.datapoints:
                self.total_include_seconds += datapoint.total_seconds


    def print_users(self, users: list[User]):
        for user in users:
            if len(users) > 1:
                print(f"- {user.name.upper()} -")
            if user.total_seconds <= 0:
                print(f"{user.name.upper()} has not coded within the range {used_range if used_range else start_time + ' .. ' + end_time}")
                continue
            stats = user.datapoints
            if print_reversed:
                stats = [*reversed(stats)]

            time_total = self.day_count * 86400

            langs = []
            for item in stats:
                langs.append({"name": item.name, "total_seconds": item.total_seconds, "percent": item.total_seconds / self.total_seconds * 100})

            printer = language_printer()

            total_secs, total_pct = printer(langs, self.total_include_seconds)

            print(f"--------------\nTOTAL: {convertsecs(total_secs)} ({total_pct:.02f}%)")
            print(f"--------------\nAVG {convertsecs(round(total_secs / time_total * 86400))} time/day\n")

    def print_line_items(self, label: str = ""):
        if label:
            print(f"------------------\n{label}\n------------------")

        self.print_users(self.users)

    def apply_combine_users(self):
        langs = {}
        total_user_seconds = 0
        for user in self.users:
            for datapoint in user.datapoints:

                if langs.get(datapoint.name):
                    langs[datapoint.name] += datapoint.total_seconds
                else:
                    langs[datapoint.name] = datapoint.total_seconds
                total_user_seconds += datapoint.total_seconds

        langs = {k: v for k, v in sorted(langs.items(), key=lambda k: k[1], reverse = True)}
        self.users = [CombinedUser("COMBINED", total_user_seconds, [
                DataPoint(name, s) for name, s in langs.items()
                ], original_users = {u.name: u for u in self.users})]

    def print_combined_users(self):
        langs = {}
        user_langs = defaultdict(lambda: defaultdict(int))
        for user in self.users:
            for datapoint in user.datapoints:
                if isinstance(user, CombinedUser):
                    for og in user.original_users:
                        dp = user.original_users[og].getdpByName(datapoint.name)
                        if dp:
                            user_langs[og][datapoint.name] += dp.total_seconds
                else:
                    user_langs[user.name][datapoint.name] += datapoint.total_seconds

                if langs.get(datapoint.name):
                    langs[datapoint.name] += datapoint.total_seconds
                else:
                    langs[datapoint.name] = datapoint.total_seconds

        langs = [{"name": name, "total_seconds": s, "percent": s / self.total_seconds * 100} for name, s in sorted(langs.items(), key = lambda i: i[1], reverse = True)]

        printer = language_printer(user_langs)
        total_secs, total_pct = printer(langs, self.total_include_seconds)
        print(f"--------------\nTOTAL: {convertsecs(total_secs)} ({total_pct:.02f}%)")
        print(f"--------------\nAVG {convertsecs(round(total_secs / self.total_seconds * 86400))} time/day\n")

def parse_qualifiers(quals: list[str]):
    milestones = []
    time_milestones = []
    for qual in quals:
        if ":" in qual:
            time_milestones.append(qual)
        #qual must not be empty string
        elif qual:
            milestones.append(float(qual))
    return milestones, time_milestones

if args:
    milestones, time_milestones = parse_qualifiers(args)

std = STDData([], 0, 0)

for user in user.split(","):
    if read_from:
        if read_from == "-":
            raw = json.loads("".join(sys.stdin.readlines()))
        else:
            with open(read_from) as f:
                raw = json.load(f)

    elif data_fmt == "stats":
        query = ""
        params = {}
        if for_project:
            params["project"] = for_project
        params = urlencode(params)
        with request.urlopen(f"{api}/api/compat/wakatime/v1/users/{user}/stats/{used_range}?{params}") as res:
            html = res.read()
            raw = json.loads(html)
    elif data_fmt == "leaders":
        with request.urlopen(f"{api}/api/compat/wakatime/v1/leaders") as res:
            html = res.read()
            raw = json.loads(html)
    else:
        key = os.getenv("WAKA_KEY")
        if not key:
            print("the $WAKA_KEY env var must be set to use -F without -f", file=sys.stderr)
            exit(1)
        params = {}
        if used_range:
            params["range"] = used_range
        elif start_time != "" and end_time == "":
            end_time = datetime.datetime.now().strftime("%Y-%m-%d")
        elif start_time == '' or end_time == '':
            print("Cannot use -F summary with no -f without setting -S AND -E", file=sys.stderr)
            exit(1)
        if start_time:
            params["start"] = start_time
            params["end"] = end_time
        if for_project:
            params["project"] = for_project
        params = urlencode(params)
        req = request.Request(f"{api}/api/compat/wakatime/v1/users/{user}/summaries?{params}", headers={
            "Authorization": f"Basic {key}"
            })
        with request.urlopen(req) as res:
            html = res.read()
            raw = json.loads(html)


    if data_fmt == "stats":
        std.users.append(
                User(
                    raw["data"]["username"],
                    raw["data"]["total_seconds"],
                    [DataPoint(name=l["name"], total_seconds=l["total_seconds"]) for l in raw["data"][section]]
                )
        )
        std.total_seconds += raw["data"]["total_seconds"]
        #not += because it's not communitive
        std.day_count = raw["data"]["days_including_holidays"] + 1

    #-Fleaders ignores -u
    elif data_fmt == "leaders":
        start_ts = datetime.datetime.strptime(raw["range"]["start_date"][0:10], "%Y-%m-%d")
        end_ts = datetime.datetime.strptime(raw["range"]["end_date"][0:10], "%Y-%m-%d")
        day_count = int((end_ts.timestamp() - start_ts.timestamp()) / 86400)
        total_seconds = 0
        for user in raw["data"]:
            total_seconds += user["running_total"]["total_seconds"]
        std = STDData(
                users = [User(
                             u["user"]["display_name"],
                             u["running_total"]["total_seconds"],
                             [DataPoint(**d) for d in u["running_total"]["languages"]]
                         ) for u in raw["data"]
                         ],
                day_count = day_count,
                total_seconds = total_seconds
        )
    elif data_fmt == "summary":
        day_count = raw["daily_average"]["days_including_holidays"]
        datapoints = {}
        seconds = 0
        for day in raw["data"]:
            start = day["range"]["start"][0:19]
            end = day["range"]["end"][0:19]
            day = day[section]
            for dp in day:
                seconds += dp["total_seconds"]
                if datapoints.get(dp["name"]):
                    datapoints[dp["name"]] += dp["total_seconds"]
                else:
                    datapoints[dp["name"]] = dp["total_seconds"]

        datapoints = [DataPoint(name = name, total_seconds = s) for name, s in sorted(datapoints.items(), key = lambda i: i[1], reverse = True)]
        std.day_count = day_count
        std.total_seconds += seconds
        std.users.append(User(name = user or "UNKNOWN", datapoints = datapoints, total_seconds = seconds))

    else:
        exit()

if to_find == "most-used":
    std.apply_combine_users()

std.calculate_total_included_secs()

std.apply_combine(combine_as)

if include_langs or exclude_langs or top > 0:
    std.apply_include()

std.apply_qual(qual_gt, qual_lt)

if output_fmt == "line":
    std.print_line_items()
elif output_fmt == "combine-users":
    std.print_combined_users()
